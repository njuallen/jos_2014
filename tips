# Tips for the lab
##lab1

##lab2

###boot_alloc
In boot_alloc, we allocate a small amount of memory from the remapped physical memory(see memlayout.h). What's more, note that, we only remapped 4MB of physical memory. If you try to access any memory address above (0xf0400000 -1), you will encounter a triple fault, which causes qemu to reboot.
When we are using "make qemu-nox", it outputs no special message when rebooting.

###page_init
Read the definition of a macro or function provided by TA, make sure you understand what they are doing exactly.
In writing page_init, I used the PTX macro instead of the PGNUM macro. This wastes me much time.

###pgdir_walk
Setting up permission bits in both the page directory and the page table is complex. So we'd better leave permissions in the page directory more permissive than strictly necessary(See Hint 2). So, we could set up the permission bits for pde just like this:
	*pde = page2pa(ptable) | PTE_P | PTE_U | PTE_W;
This line in check_page actually checks this:
	assert(kern_pgdir[0] & PTE_U);
You can read i386-manual 6.4 for more information on directory and page protection.

###triple fault的调试
使用 -d int，在结合qemu.log以及手册的说明，查看对应error code的含义。
另外由于在entry.S中，我们设置了cr0的wp位，所以写一个只读页是非法的，即使按照手册，处于内核态时你对所有页都可读可写。因此对于kernel可写的页，我们应该显式地加上PTE_W flag。

###设置es，ds寄存器
汇编器似乎只允许将ax之类的寄存器的值赋值给es,ds。因此我们必须要这样写：
movw $GD_KD, %ax
movw %ax, %es
movw %ax, %ds

###trap_dispatch
trap_dispatch最后有一个env_destroy，那个是针对其他exception的。对于syscall，我们应该返回到用户进程，而不应该destroy用户进程，如果destroy了它，你就无法通过testbss。
