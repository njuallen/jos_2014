# Tips for the lab
##lab1

##lab2

###boot_alloc
In boot_alloc, we allocate a small amount of memory from the remapped physical memory(see memlayout.h). What's more, note that, we only remapped 4MB of physical memory. If you try to access any memory address above (0xf0400000 -1), you will encounter a triple fault, which causes qemu to reboot.
When we are using "make qemu-nox", it outputs no special message when rebooting.

###page_init
Read the definition of a macro or function provided by TA, make sure you understand what they are doing exactly.
In writing page_init, I used the PTX macro instead of the PGNUM macro. This wastes me much time.

###pgdir_walk
Setting up permission bits in both the page directory and the page table is complex. So we'd better leave permissions in the page directory more permissive than strictly necessary(See Hint 2). So, we could set up the permission bits for pde just like this:
	*pde = page2pa(ptable) | PTE_P | PTE_U | PTE_W;
This line in check_page actually checks this:
	assert(kern_pgdir[0] & PTE_U);
You can read i386-manual 6.4 for more information on directory and page protection.

###triple fault的调试
使用 -d int，在结合qemu.log以及手册的说明，查看对应error code的含义。
另外由于在entry.S中，我们设置了cr0的wp位，所以写一个只读页是非法的，即使按照手册，处于内核态时你对所有页都可读可写。因此对于kernel可写的页，我们应该显式地加上PTE_W flag。

###设置es，ds寄存器
汇编器似乎只允许将ax之类的寄存器的值赋值给es,ds。因此我们必须要这样写：
movw $GD_KD, %ax
movw %ax, %es
movw %ax, %ds

###trap_dispatch
trap_dispatch最后有一个env_destroy，那个是针对其他exception的。对于syscall，我们应该返回到用户进程，而不应该destroy用户进程，如果destroy了它，你就无法通过testbss。

###mpentry.s中使用的一些小技巧
mpentry.S的代码只有一份，但我们要给每个cpu设置不同的内核栈，因此这里采取的方式是将mpentry.S中设置的栈的值变成kernel中的一个全局变量，而汇编代码文件中对其的访问最终链接到那里。我们只要按顺序将其设为不同的值即可。

##lab3
###load_icode
在load_icode里面。最好根据elf段的读写权限合理设置页的属性，不要全部设置成读写。

##lab4

###pfentry.S和set_pgfault_handler
entrycode的完成要仔细想一想，同时一定要遵从注释的说明！！！但是要理解我们给用户封装的这个set_pgfault_handler这个接口并不是直接把用户给的handler用来注册给OS。我们要想办法让控制权先进entrycode，再跳转到用户的handler。因此我们在实现set_pgfault_handler时并不是每次调用它都要通过系统调用重新注册handler。我们通过系统调用注册的是一个固定的入口点：entrycode。因此我们只需要在第一次时通过系统调用注册它。这里通过链接的方式，让C代码和entrycode里的汇编代码完美配合（参见_pgfault_handler变量）。
操作系统只管把控制权转移到lib里的entrycode，而用户态的lib负责将控制权再转移到用户定义的handler上去。
我那个set_pgfault_handler里没有做太多的错误处理，系统调用只要一出错，就panic。

###duppage
在duppage中，我们要更改我们当前地址空间中这一页的权限，不能采用先page_unmap在page_map的方式，因为有可能你当前unmap的页正好放着你当前正在执行的的代码。如果你把当前页unmap了，你有可能再也无法执行接下来的map了。所以正确的方式是直接用map，把子进程地址空间中的对应页map过来或者把当前地址空间中其他页map过来，通过这种方式来更改权限。

###对uvpt的访问
看了讲义上的说法，你可能认为uvpt那4MB空间真的是连续的，然后就直接对uvpt进行下标访问了，然后就会出page fault。仔细想一想，我们就会发现page_directory中并不是每一项都有效，那1024个二级页表中有好多实际是没有分配的。我们必须要先检查uvpd，看看我们要访问的某一个二级页表是否存在，然后才能访问。我把检查加访问合并成了一个函数叫做get_pte，如果访问的页表项不存在，就返回0。还有一个要注意的是，在fork中，我们对每个存在的页都要duppage，但是由于绝大部分页都是不存在的，那个for循环如果写成两重的话，如果发现页表不存在，就不再检查里面的页表项了，这样子会更快。

###帮助子进程注册pgfault_upcall的问题
child与parent拥有相同的地址空间，这意味着他们在lib中的那个_pgfault_handler拥有同样的值，但是他们各自在env结构体中的upcall入口点却有不同的值。因为father调用set_pgfault_handler，注册了入口点，同时更改了内存中的_pgfault_handler。child由于和father拥有相同的地址空间，它与father拥有相同的_pgfault_handler。但子进程的env结构体中的page fault入口点却与father不同。sys_exo_fork中只拷贝env结构体中的寄存器值，其他的任何东西都没有被拷贝。
所以，父进程还必须要帮子进程注册pgfault_upcall。子进程不能自己注册，因为子进程的栈是copy on write的，现在无法向栈上写任何东西，因而无法进行任何函数调用。

###page_fault_handler中check函数的问题
注释说：
// If there's no page fault upcall, the environment didn't allocate a
// page for its exception stack or can't write to it, or the exception
// stack overflows, then destroy the environment that caused the fault.
// Note that the grade script assumes you will first check for the page
// fault upcall and print the "user fault va" message below if there is
// none.  The remaining three checks can be combined into a single test.
后三类的check可以合并成一个，那就是对当前UTrapframe是否可写的检查，我们只需要使用一个user_mem_check检查一下当前的UTrapframe是否可以写在栈上就可以了。只有这样才能通过part B的若干个test。

###IDT的初始化
JOS中，在kernel中，是关中断的。所以所有的IDT表项都必须设置为中断门，让硬件自动关中断，而不能设置为陷阱门。硬件自动关中断后，在iret时会把栈上的eflags自动pop回去，顺便就开了中断。

###sys_ipc_try_send
这里面要求我们可以将任意一个进程的一个page重新共享给其他任意进程。因此我们不能使用sys_page_map，因为sys_page_map里面会做一系列的权限检查(envid2env中)，保证当前进程只可以操作自己以及自己的子进程的内存映射。send page中子进程尝试向父进程发一个页，但这是不行的，因为如果使用sys_page_map，子进程会因为权限问题而无法给父进程重新映射一页。因此我重新写了一个仅供内核调用的，不进行任何权限检查的函数page_map，并让sys_page_map和sys_ipc_try_send分别调用它，只不过它们各自进行不同的权限检查。这样子就可以通过send page了。

###lapic_eoi
由于这边的中断控制器似乎不是我们常见的那种偷懒的自动发送eoi，而是要手动发送eoi。所以在中断处理完了之后，必须要手动发送eoi信号给中断控制器，否则中断就只能来一次。后续的中断来了就无法进来。

###gobang游戏的若干问题
要让gobang游戏像其他的测试程序一样链接进kernel，只要改一改kernel的Makefrag文件即可。但是即使链接进去之后，仍然会出现黑屏，kernel运行不正确，并不断重启的问题。我认为是由于gobang游戏过大，导致kernel过大导致的。我查看了一下kernel的大小达到了4.1M，这样子运行是不行的。解决方案无非就是将游戏放到磁盘上，或者减小游戏的体积。我决定采取后者。那两幅图片谁胜利的图片是不必要的，完全可以删去。将那两幅图片删掉之后，kernel大小降到了1.3M，已经能够正常运行了。

###关于显存
为了提高效率，显存我是直接让用户读写的。

###在JOS中实现线程
为了好向助教交差，我在JOS中实现了简单的线程。线程最重要的就是地址空间的共享。于是我利用JOS的进程机制实现了线程，并实现了vfork，以fork出一个进程，但这个进程与父进程拥有同样的地址空间，也就是说他们的cr3值是一样的。为了让一个线程消亡，并执行env_destroy时不会将整个地址空间都销毁掉，我通过对页目录表的引用计数来判断整个进程是否结束。

每个线程都有属于自己的栈，为了做到这一点，我在用户态的lib里，通过一些数据结构来记录当前哪些线程用了哪些页作为栈，并封装出了jthread_create等函数，确保不同线程的栈不会冲突。线程在消亡之后，它的栈所占用的空间不会被释放，但是由于新释放的线程控制块总是插入在free_list的头部，所以他们的栈空间会被后来的线程重用。这样子就在一定程度上减少了内存空间的浪费。

我们这个线程本质上还是进程，只不过是共用一个地址空间的进程，所以他们的线程号与进程号实际上是相同的。对线程直接使用其进程号来标识。

同时，为了在语义上接近POSIX thread，方便使用，我们的jthread_create也支持参数的传递，参数从原来的栈拷贝到新栈上，并切换到到相应的代码段执行，这都是在用户态完成的。同时里面也有一些非常tricky的代码。

注意：由于可能有多个线程调用jthread库中的函数，jthread库必须上锁，我将kernel中的spinlock移植了过来。就thread库只使用了一把粒度极大的锁。

###jthread信号量
要想在jthread中阻塞线程或者唤醒线程，如果不给内核增加新的功能，就需要使用set_status或者使用ipc来阻塞或唤醒。通过set_status我们可以将进程设置可执行或不可执行，而通过ipc_recv可以阻塞一个线程，向其发送一个信号之后，它又可以被唤醒。但这两种方案都有问题：

在内核中，set_status会检查权限，只有父进程可以给子进程发送消息，这样子我们的“线程”之间无法互相唤醒。

而通过ipc系列系统调用的问题就是：ipc系列的系统调用原来是为进程间通讯准备的，我们的“线程”要用它来实现通讯必然会出现一些问题：
1. 进程可以通过调用ipc_recv来阻塞自己，然后另一个线程通过ipc_send来唤醒它。但问题是，系统中的其他进程也可以通过向他发消息，使他唤醒。
2. 我们这个多线程是用多进程模拟的，我们多个进程共享一个地址空间，全局变量的问题没有得到很好的解决。尤其是thisenv这个全局变量。ipc中通过thisenv来检查接收到的数值，而我们多个进程由于是共享一个地址空间，因而也只有一个全局变量。由于thisenv始终是由主线程设置的，其他线程无法查看到自己的thisenv。因此我们这个多线程与原有的进程间通信实际上不兼容的。
