# Tips for the lab
##lab1

##lab2

###boot_alloc
In boot_alloc, we allocate a small amount of memory from the remapped physical memory(see memlayout.h). What's more, note that, we only remapped 4MB of physical memory. If you try to access any memory address above (0xf0400000 -1), you will encounter a triple fault, which causes qemu to reboot.
When we are using "make qemu-nox", it outputs no special message when rebooting.

###page_init
Read the definition of a macro or function provided by TA, make sure you understand what they are doing exactly.
In writing page_init, I used the PTX macro instead of the PGNUM macro. This wastes me much time.

###pgdir_walk
Setting up permission bits in both the page directory and the page table is complex. So we'd better leave permissions in the page directory more permissive than strictly necessary(See Hint 2). So, we could set up the permission bits for pde just like this:
	*pde = page2pa(ptable) | PTE_P | PTE_U | PTE_W;
This line in check_page actually checks this:
	assert(kern_pgdir[0] & PTE_U);
You can read i386-manual 6.4 for more information on directory and page protection.

###triple fault的调试
使用 -d int，在结合qemu.log以及手册的说明，查看对应error code的含义。
另外由于在entry.S中，我们设置了cr0的wp位，所以写一个只读页是非法的，即使按照手册，处于内核态时你对所有页都可读可写。因此对于kernel可写的页，我们应该显式地加上PTE_W flag。

###设置es，ds寄存器
汇编器似乎只允许将ax之类的寄存器的值赋值给es,ds。因此我们必须要这样写：
movw $GD_KD, %ax
movw %ax, %es
movw %ax, %ds

###trap_dispatch
trap_dispatch最后有一个env_destroy，那个是针对其他exception的。对于syscall，我们应该返回到用户进程，而不应该destroy用户进程，如果destroy了它，你就无法通过testbss。

###mpentry.s中使用的一些小技巧
mpentry.S的代码只有一份，但我们要给每个cpu设置不同的内核栈，因此这里采取的方式是将mpentry.S中设置的栈的值变成kernel中的一个全局变量，而汇编代码文件中对其的访问最终链接到那里。我们只要按顺序将其设为不同的值即可。

##lab4
没有特别的坑，专心照着讲义以及注释的指示完成就好了。但是在完成那些函数后，要自己把对那些函数的调用加到syscall里面。
